<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RocXing&#39; BLOG</title>
  
  <link href="/blog/public/atom.xml" rel="self"/>
  
  <link href="http://rocxing.github.io/blog/public/"/>
  <updated>2017-11-08T08:00:09.877Z</updated>
  <id>http://rocxing.github.io/blog/public/</id>
  
  <author>
    <name>RocXing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dynamic Routing Between Capsules</title>
    <link href="http://rocxing.github.io/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/"/>
    <id>http://rocxing.github.io/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/</id>
    <published>2017-11-07T09:21:24.000Z</published>
    <updated>2017-11-08T08:00:09.877Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;有“深度学习之父”与“神经网络先驱”之称的Geoffrey E. Hinton终于在NIPS 2017大会上发表了酝酿已久的一篇关于Capsule的论文《Dynamic Routing Between Capsules》。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;p&gt;Capsule是一组神经元，其活动向量表示特定类型实体或属性的实例化参数。在本文中，使用活动向量的长度来表示实体存在的概率，而其方向表示实例化参数。活跃的Capsule通过变换矩阵来预测更高级别Capsule的实例化参数。当多个预测一致时，更高级别的Capsule变得活跃。&lt;/p&gt;
&lt;p&gt;实验表明多层Capsule系统达到MNIST的先进的性能，在识别高度重叠数字上比卷积神经网络好得多。为了达到这种效果，文中使用了迭代的Routing-by-agreement机制：低级别的Capsule更倾向于将输出发送到其预测与相应活动向量的标量积更大的高级别Capsule。&lt;/p&gt;
&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;人类视觉通过一系列注视点来获取物体对象的高解析度特征，而忽略无关细节。人类在识别人脸时，并不是将图像的所有信息输入大脑，而是提取其中的特征点。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/1.png&quot; alt=&quot;1.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;文中假设我们的多层视觉系统对于每个注视点创建了某种类似于解析树的东西。每层都被分为许多组的神经元被称为“Capsule”，而解析树中的每个节点都对应一个活跃的Capsule。通过迭代的路由过程，每个活跃的Capsule会选择高层次的Capsule作为它在树中的父母节点。对于高层次的视觉系统，这种迭代过程会解决为整体分配部分的问题。&lt;/p&gt;
&lt;p&gt;Routing-by-agreement路由机制比“Max-pooling”更有效，后者在局部池中忽略了除最活跃的特征探测器以外的所有神经元。&lt;/p&gt;
&lt;h1 id=&quot;Capsule的向量输入与输出的计算&quot;&gt;&lt;a href=&quot;#Capsule的向量输入与输出的计算&quot; class=&quot;headerlink&quot; title=&quot;Capsule的向量输入与输出的计算&quot;&gt;&lt;/a&gt;Capsule的向量输入与输出的计算&lt;/h1&gt;&lt;p&gt;本文使用了一个非线性的压扁（squashing）函数，来保证输入的短向量会缩小到接近0而长向量只会缩小到微微小于1。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/2.png&quot; alt=&quot;2.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;对Capsule j的输入向量sj，首先计算得到它的单位向量，如果sj的长度即2- 范数比1小的多，那么这个单位向量就会压扁到接近0。反之如果长度很大那么系数会接近于1。vj为Capsule j的输出向量。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/3.png&quot; alt=&quot;3.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;每个Capsule j的输入向量sj由上一层的所有预测向量uj|i加权求和得到，而uj|i则通过变换矩阵Wij与上一层Capsule的输出ui相乘得到。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/4.png&quot; alt=&quot;4.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;cij是由迭代的动态路由过程决定的连接系数，通过“routing softmax”得到。“routing softmax”的初始bij则为Capsule i应该连接Capsule j的log先验概率。&lt;/p&gt;
&lt;p&gt;路由算法如下&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/5.png&quot; alt=&quot;5.png&quot; title=&quot;&quot;&gt;
&lt;h1 id=&quot;边际损失&quot;&gt;&lt;a href=&quot;#边际损失&quot; class=&quot;headerlink&quot; title=&quot;边际损失&quot;&gt;&lt;/a&gt;边际损失&lt;/h1&gt;&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/6.png&quot; alt=&quot;6.png&quot; title=&quot;&quot;&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/7.png&quot; alt=&quot;7.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;阈值m+和m-分别为0.9和0.1，意味着当向量vc长度大于0.9或小于0.1时损失会被忽略。&lt;/p&gt;
&lt;h1 id=&quot;CapsNet结构&quot;&gt;&lt;a href=&quot;#CapsNet结构&quot; class=&quot;headerlink&quot; title=&quot;CapsNet结构&quot;&gt;&lt;/a&gt;CapsNet结构&lt;/h1&gt;&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/8.png&quot; alt=&quot;8.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;从左侧输入一张图片，用9*9的卷积核进行特征提取，因此紧接输入的那一层其实是一个卷积层。 &lt;/p&gt;
&lt;p&gt;卷积层提取特征后作为输入送入PrimaryCaps，PrimaryCaps是一个卷积 Capsule层，里面有32个通道，也就是一层里面有32&lt;em&gt;6&lt;/em&gt;6个capsule（每个通道有6&lt;em&gt;6个Capsule），其中每个通道中每个Capsule输出一个8维向量，一个通道的输出向量就是6&lt;/em&gt;6*8。 &lt;/p&gt;
&lt;p&gt;PrimaryCaps和DigitCaps之间还有一个权重矩阵Wij，代表Capsule i 和Capsule j 的输出向量（8维和16维）之间的权重。同一个通道里的Capsule共享相同的权重。接着PrimaryCaps的是一个DigitCaps，这个可以看做是一个预测层，共有10个Capsule，每个Capsule对应0~9共10个数字，然后每个Capsule的输出是一个16维的向量。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/9.png&quot; alt=&quot;9.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;解码器用于将DigitCaps里正确数字对应的Capsule向量，通过三层全连接模型，重新构建出输入的数字图片。重构损失由与原像素强度的平方差之和定义，并且有一个为0.0005的系数以确保在训练过程中不会过度影响边际损失。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/11/07/Dynamic-Routing-Between-Capsules/10.png&quot; alt=&quot;10.png&quot; title=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;最后的实验结果标明DigitCaps Capsule所学习到的表达具有更强大鲁棒性，在未进行对自由变换图形训练的情况下能够较CNN更好的识别自由变换的数字。与此同时，动态路由机制保证了网络层之间传递信息过程中没有损失过多，允许高层Capsule同时受到低层多个活跃Capsule的影响，因此还能够分离高度重合的数字。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有“深度学习之父”与“神经网络先驱”之称的Geoffrey E. Hinton终于在NIPS 2017大会上发表了酝酿已久的一篇关于Capsule的论文《Dynamic Routing Between Capsules》。&lt;/p&gt;
&lt;/blockq
    
    </summary>
    
      <category term="Machine Learning" scheme="http://rocxing.github.io/blog/public/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://rocxing.github.io/blog/public/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Batch Normalization Accelerating Deep Network Training by Reducing Internal Covariate Shift</title>
    <link href="http://rocxing.github.io/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/"/>
    <id>http://rocxing.github.io/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/</id>
    <published>2017-10-30T07:08:31.000Z</published>
    <updated>2017-10-30T08:37:35.618Z</updated>
    
    <content type="html">&lt;p&gt;Batch Normalization是Google于2015年在ICML论文中提出的一种用于加速深度神经网络训练的一种方法。&lt;/p&gt;
&lt;p&gt;在训练深度神经网络时，由于训练过程中每层的连接参数都在通过反向传播不断变化，从而导致每层所学习的输入样本的分布都在发生变化。这种现象被称作Internal Covariate Shift即内部协变量位移，会随着网络的深度增加而放大。内部协变量位移的存在使得在每个训练循环中，参数都必须重调以补偿输入分布的改变，限制了更大学习速率的使用。同时易使非线性神经元如sigmoid、tanh饱和，导致深度网络的梯度消失，这致使需要谨慎小心的初始化网络的参数。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/formula1.png&quot; alt=&quot;formula1.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;Batch Normalization通过固定每层输入的均值与方差，大大降低了内部协变量位移的影响，减少了对在参数规模上梯度和初始化的依赖，从而允许更大的学习速率，降低了发散的风险，加快了深度神经网络的训练。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/formula2.png&quot; alt=&quot;formula2.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;与将每层输入进行Whitening即白化处理不同，Batch Normalization做出了只独立计算期望与方差的简化，不需要对每个样本都计算协方差矩阵与逆，降低了计算成本。期望与方差只使用mini-batch估计，以适应随机梯度下降算法。为了为确保每层规范化后的输入与原输入仍是恒等变换，引入了两对参数，用以保证每层的非线性学习能力。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/formula4.png&quot; alt=&quot;formula4.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;另外，Batch Normalization使得每个训练样本都与整个mini-batch相关，消除了对某个特征的强依赖，因此具有一定的Regularization效果，甚至不再需要Dropout。&lt;/p&gt;
&lt;img src=&quot;/blog/public/2017/10/30/Batch-Normalization-Accelerating-Deep-Network-Training-by-Reducing-Internal-Covariate-Shift/formula3.png&quot; alt=&quot;formula3.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;通过链式法则，可以得出Batch Normalization变换的导数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Batch Normalization是Google于2015年在ICML论文中提出的一种用于加速深度神经网络训练的一种方法。&lt;/p&gt;
&lt;p&gt;在训练深度神经网络时，由于训练过程中每层的连接参数都在通过反向传播不断变化，从而导致每层所学习的输入样本的分布都在发生变化。这种现象
    
    </summary>
    
      <category term="Machine Learning" scheme="http://rocxing.github.io/blog/public/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://rocxing.github.io/blog/public/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的相等性判断</title>
    <link href="http://rocxing.github.io/blog/public/2016/06/28/JavaScript%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%80%A7%E5%88%A4%E6%96%AD/"/>
    <id>http://rocxing.github.io/blog/public/2016/06/28/JavaScript中的相等性判断/</id>
    <published>2016-06-28T08:03:13.000Z</published>
    <updated>2016-06-28T08:25:08.082Z</updated>
    
    <content type="html">&lt;h1 id=&quot;JavaScript-中的相等性判断&quot;&gt;&lt;a href=&quot;#JavaScript-中的相等性判断&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的相等性判断&quot;&gt;&lt;/a&gt;JavaScript 中的相等性判断&lt;/h1&gt;&lt;p&gt;JavaScript 提供三种不同的比较操作符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;严格相等，使用 ===&lt;/li&gt;
&lt;li&gt;（非严格）相等，使用 ==&lt;/li&gt;
&lt;li&gt;Object.is （ECMAScript 6 新特性）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两等号判等会在比较时进行类型转换；三等号判等不会进行类型转换（如果类型不同会直接返回 false ）； Object.is 在三等号判等的基础上特别处理了 NaN 、 -0 和 +0 ，保证 -0 和 +0 不再相同，但 Object.is(NaN, NaN) 会返回 true。（像其他数值一样比较 NaN ——由于 IEEE 754 的规范，无论使用双等号或三等号，比较 NaN 都会得到 false ）&lt;/p&gt;
&lt;h2 id=&quot;严格相等&quot;&gt;&lt;a href=&quot;#严格相等&quot; class=&quot;headerlink&quot; title=&quot;严格相等 ===&quot;&gt;&lt;/a&gt;严格相等 ===&lt;/h2&gt;&lt;p&gt;全等操作符比较两个值是否相等，两个被比较的值在比较前都不进行隐式转换。如果两个被比较的值具有不同的类型，这两个值是不全等的。否则，如果两个被比较的值类型相同，值也相同，并且都不是 number 类型时，两个值全等。最后，如果两个值都是 number 类型，当两个都不是 NaN，并且数值相同，或是两个值分别为 +0 和 -0 时，两个值被认为是全等的。（等式 (x !== x) 成立的唯一情况是 x 的值为 NaN）&lt;/p&gt;
&lt;h2 id=&quot;非严格相等&quot;&gt;&lt;a href=&quot;#非严格相等&quot; class=&quot;headerlink&quot; title=&quot;非严格相等 ==&quot;&gt;&lt;/a&gt;非严格相等 ==&lt;/h2&gt;&lt;p&gt;相等操作符比较两个值是否相等，在比较前将两个被比较的值转换为相同类型。在转换后（等式的一边或两边都可能被转换），最终的比较方式等同于全等操作符 === 的比较方式。 相等操作符满足交换律。&lt;/p&gt;
&lt;h2 id=&quot;什么时候使用-Object-is-或是三等&quot;&gt;&lt;a href=&quot;#什么时候使用-Object-is-或是三等&quot; class=&quot;headerlink&quot; title=&quot;什么时候使用 Object.is 或是三等&quot;&gt;&lt;/a&gt;什么时候使用 Object.is 或是三等&lt;/h2&gt;&lt;p&gt;总的来说，除了对待NaN的方式，Object.is唯一让人感兴趣的，是当你需要一些元编程方案时，它对待0的特殊方式，特别是关于属性描述器，即你的工作需要去镜像Object.defineProperty的一些特性时。如果你的工作不需要这些，那你应该避免使用Object.is，使用===来代替。即使你需要比较两个NaN使其结果为true，总的来说编写使用NaN 检查的特例函数(用旧版本ECMAScript的isNaN方法)也会比想出一些计算方法让Object.is不影响不同符号的0的比较更容易些。&lt;/p&gt;
&lt;p&gt;转自MDN &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-中的相等性判断&quot;&gt;&lt;a href=&quot;#JavaScript-中的相等性判断&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 中的相等性判断&quot;&gt;&lt;/a&gt;JavaScript 中的相等性判断&lt;/h1&gt;&lt;p&gt;JavaSc
    
    </summary>
    
      <category term="JavaScript" scheme="http://rocxing.github.io/blog/public/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://rocxing.github.io/blog/public/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编码和Endian</title>
    <link href="http://rocxing.github.io/blog/public/2015/11/04/%E7%BC%96%E7%A0%81%E5%92%8CEndian/"/>
    <id>http://rocxing.github.io/blog/public/2015/11/04/编码和Endian/</id>
    <published>2015-11-04T05:17:42.000Z</published>
    <updated>2016-06-28T07:05:03.059Z</updated>
    
    <content type="html">&lt;h1 id=&quot;UTF-8编码&quot;&gt;&lt;a href=&quot;#UTF-8编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-8编码&quot;&gt;&lt;/a&gt;UTF-8编码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;UTF-8是Unicode的实现方式之一。&lt;br&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UTF-8的编码规则很简单，只有二条：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/li&gt;
&lt;li&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解读UTF-8编码非常简单，如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。&lt;/p&gt;
&lt;h1 id=&quot;Endian&quot;&gt;&lt;a href=&quot;#Endian&quot; class=&quot;headerlink&quot; title=&quot;Endian:&quot;&gt;&lt;/a&gt;Endian:&lt;/h1&gt;&lt;p&gt;数据在内存中的存储，其字节序可分为两种，Big endian和Little endian。对于十六进制表示的两字节数0x1234来说——&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Big endian&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;地址：|0x00|0x01|&lt;/p&gt;
&lt;p&gt;内容：|0x12|0x34|&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;低地址位存储高位字节&lt;/strong&gt;，就像我们生活中正常写数字一样，从左到右读，数位由高到低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Little endian&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;地址：|0x00|0x01|&lt;/p&gt;
&lt;p&gt;内容：|0x34|0x12|&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;低地址位存储低位字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;C语言中判断机器是Big endian还是Little endian：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0x1234&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; b = *(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;*)&amp;amp;a;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(b == &lt;span class=&quot;number&quot;&gt;0x12&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;big end\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;little end\n&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UTF-8编码&quot;&gt;&lt;a href=&quot;#UTF-8编码&quot; class=&quot;headerlink&quot; title=&quot;UTF-8编码&quot;&gt;&lt;/a&gt;UTF-8编码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;UTF-8是Unicode的实现方式之一。&lt;br&gt;UTF-8最大的一个特点
    
    </summary>
    
      <category term="计算机基础" scheme="http://rocxing.github.io/blog/public/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://rocxing.github.io/blog/public/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Git中级用户的25个提示</title>
    <link href="http://rocxing.github.io/blog/public/2015/08/26/Git%E4%B8%AD%E7%BA%A7%E7%94%A8%E6%88%B7%E7%9A%8425%E4%B8%AA%E6%8F%90%E7%A4%BA/"/>
    <id>http://rocxing.github.io/blog/public/2015/08/26/Git中级用户的25个提示/</id>
    <published>2015-08-26T02:47:21.000Z</published>
    <updated>2016-06-28T07:05:03.016Z</updated>
    
    <content type="html">&lt;img src=&quot;/blog/public/2015/08/26/Git中级用户的25个提示/git.png&quot; alt=&quot;[Git]&quot; title=&quot;[Git]&quot;&gt;
&lt;h1 id=&quot;基本提示&quot;&gt;&lt;a href=&quot;#基本提示&quot; class=&quot;headerlink&quot; title=&quot;基本提示&quot;&gt;&lt;/a&gt;基本提示&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1. 安装之后第一步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git config --global user&lt;span class=&quot;selector-class&quot;&gt;.name&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Some One&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git config --global user&lt;span class=&quot;selector-class&quot;&gt;.email&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;someone@gmail.com&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2. Git 是以指针为基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储在 git 中的所有东西都包含在一个文件中。当你提交的时候，git 会创建一个包含提交消息和相关数据的文件（名称、邮件、日期/时间、上一次提交等等），并将其链接到一个树形文件。树形文件包含一个对象列表或者其它树。对象或二进制大数据对象（BLOB）是提交的真正内容（一个文件，如果你愿意，虽然文件名没有存储在对象中，但会存储在树中）。所有这些文件都以对象的 SHA-1 哈希为文件名进行存储。&lt;/p&gt;
&lt;p&gt;分支和标签只是一些文件，这些文件包含（基本上）一个指向提交的 SHA-1 哈希值。使用这些引用在灵活性和速度上均有大幅提升，创建一个新的分支就和创建一个文件一样简单，只是这个文件带有分支名称和一个包含指向提交（你从这个提交建立分支）的SHA-1哈希值。当然，当你使用 Git 命令行工具（或一个图形用户界面）时，你永远也不会这么做，但它就是这么简单。&lt;/p&gt;
&lt;p&gt;你可能已经听说过对 HEAD 的引用。它只是一个包含 SHA-1 引用的文件，这个引用指向你当前的提交。如果你正在解决一个合并冲突问题，查看一下 HEAD，你会发现，它与一个特定的分支或分支上的特定点无关，只和你现在的位置有关。&lt;/p&gt;
&lt;p&gt;所有的分支指针保存在 .git/refs/heads 目录下，HEAD 在 .git/HEAD 目录下，标签在 .git/refs/tags 目录下 - 你可以随意看看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 两个 Parents - 当然！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当在日志文件中查看一个合并提交的消息时，你会看到两个 parents（与正常提交相比）。第一个parent 是你所在的分支，第二个 parents 是你并入的分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 合并冲突&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，我确信你一定有一个合并冲突需要解决。通常情况下，通过编辑该文件，删除文件中的&amp;lt;&amp;lt;&amp;lt;&amp;lt;, ====, &amp;gt;&amp;gt;&amp;gt;&amp;gt;标记，然后保存你需要保留的代码就可以了。有时候，在任何变更之前查看代码都是一个值得推荐的做法，比如，在你对两个有冲突的分支采取行动之前。这是又一个命令：&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git diff --merge&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;diff --cc dummy.rb  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;index &lt;span class=&quot;number&quot;&gt;5175&lt;/span&gt;dde,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;c65895.&lt;span class=&quot;number&quot;&gt;.4&lt;/span&gt;a00477  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;--- a/dummy.rb&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+++ b/dummy.rb&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@@@ &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; +&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; @@@&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  class MyFoo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    def say&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;-     puts &lt;span class=&quot;string&quot;&gt;&quot;Bonjour&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; -    puts &lt;span class=&quot;string&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;++    puts &lt;span class=&quot;string&quot;&gt;&quot;Annyong Haseyo&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    end&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  end&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果文件是二进制的，文件比较就不是那么容易了…你通常要做的是尝试每个版本的二进制文件，并决定使用哪一个（或者在二进制文件编辑器手动复制部分内容）。从一个特定分支下 pull 一个文件副本（如果你要合并主分支和分支132的话）：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout master flash/foo.fla &lt;span class=&quot;comment&quot;&gt;# or...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout feature132 flash/foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;# Then...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git add flash/foo.fla&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;另一种方法是从 git 中查看这个文件 - 你能够以其他文件名的方式进行查看，然后将正确的文件（当你确定它是哪一个时）复制到正常的文件名中：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;:flash/foo.fla &amp;gt; &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;-foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; feature132:flash/foo.fla &amp;gt; feature132-foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ # &lt;span class=&quot;keyword&quot;&gt;Check&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;-foo.fla &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; feature132-foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ # Let&lt;span class=&quot;string&quot;&gt;&#39;s say we decide that feature132&#39;&lt;/span&gt;s &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; correct&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ rm flash/foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ mv feature132-foo.fla flash/foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ rm &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;-foo.fla&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;add&lt;/span&gt; flash/foo.fla&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更新：感谢 Carl 在早先的的博客评论中给与的提醒，你实际上能使用 “git checkout —ours flash/foo.fla” 和 “git checkout —theirs flash/foo.fla” 检出一个特定的版本而不需要记住你要合并到哪一个分支。我个人更喜欢更明确些，但是你可以随便选择…&lt;/p&gt;
&lt;p&gt;在解决了合并冲突问题之后（就像我上面所做的那样），请记得将这个文件添加给索引。&lt;/p&gt;
&lt;h1 id=&quot;服务器、分支和标签&quot;&gt;&lt;a href=&quot;#服务器、分支和标签&quot; class=&quot;headerlink&quot; title=&quot;服务器、分支和标签&quot;&gt;&lt;/a&gt;服务器、分支和标签&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;5. 远程服务器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git 最强大的功能之一是可以有一个以上的远程服务器（另一个事实，你总是可以运行一个本地仓库）。你不一定总是需要写访问权限，你可以从多个服务器中读取（用于合并），然后写到另一个服务器中。添加一个远程服务器很简单：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git remote add john git&lt;span class=&quot;variable&quot;&gt;@github&lt;/span&gt;.&lt;span class=&quot;symbol&quot;&gt;com:&lt;/span&gt;johnsomeone/someproject.git&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想查看远程服务器的相关信息，你可以这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# shows URLs of each remote server&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git remote -v&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# gives more details about each&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git remote show name&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以查看本地分支和远程分支之间的差别：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git diff &lt;span class=&quot;literal&quot;&gt;master&lt;/span&gt;..john/&lt;span class=&quot;literal&quot;&gt;master&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也能查看不在远程分支上的 HEAD 的变化：&lt;/p&gt;
&lt;figure class=&quot;highlight erlang&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git log remote/branch..&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Note: no final refspec &lt;span class=&quot;keyword&quot;&gt;after&lt;/span&gt; ..&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;6. 标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Git 中存在两种类型的标签 - 一个轻量级标签和一个注解标签。记着第二个提示中说过 Git 是基于指针的，二者的区别很简单。一个轻量级标签无非是一个指向提交的具名指针。你可以改变它并指向另一个提交。一个注解标签是一个指向标签对象的具名指针，这个标签对象拥有自己的消息和历史。如果有需要，标签对象的消息可以采用 GPG 加密签名。&lt;/p&gt;
&lt;p&gt;创建两种类型的标签其实很容易（只是一个命令行选项的差异）&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;to-be-tested&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;-a&lt;/span&gt; v1.&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Prompts for a tag message&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;7. 创建分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Git 中创建分支非常容易（闪电般的速度，因为它仅仅需要创建一个不到100字节的文件）。创建一个新分支并切换过去的通用写法是：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git branch feature132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout feature132&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，如果你知道你要马上切换过去，你可以使用一条命令就能做到：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git checkout -&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; feature132&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你要重命名一个本地分支，同样是件容易的事（长命令方式用来显示具体执行过程）：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git checkout -&lt;span class=&quot;keyword&quot;&gt;b &lt;/span&gt;twitter-experiment feature132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-d feature132&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更新：或者你（就像 Brian Palmer 在博客文章评论中指出的那样）只使用 “git branch” 和 -m 选项就可以一步到位：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-m twitter-experiment&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;-m feature132 twitter-experiment&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;8. 合并分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在将来某个时候，你想要合并你的变更。有两种方式可以实现：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git checkout &lt;span class=&quot;keyword&quot;&gt;master&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;$&lt;/span&gt; git merge feature83 &lt;span class=&quot;comment&quot;&gt;# Or...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git rebase feature83&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;merge 和 rebase 的区别在于，merge 试图解决变更而且创建一个融合后的新提交，而 rebase 则试图把自你上次在其他分支上的变化，在另一个分支的 HAED 上重现。但是，在你向远程服务器推送一个分支之后，不要进行 rebase 操作 - 这会引发混淆/问题。&lt;/p&gt;
&lt;p&gt;如果你不能确定哪些分支仍然有独立的工作在进行 - 以便你能知道你需要合并哪一个分支以及删除哪些分支，git branch 命令有两个选项可以帮助实现这一点：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Shows branches that are all merged in to your current branch&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git branch &lt;span class=&quot;comment&quot;&gt;--merged&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Shows branches that are not merged in to your current branch&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git branch &lt;span class=&quot;comment&quot;&gt;--no-merged&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;9. 远程分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你有一个本地分支，你想让它出现在远程服务器上，你可以使用一个推送命令：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;push&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;origin&lt;/span&gt; twitter-experiment:refs/heads/twitter-experiment&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# Where &lt;span class=&quot;built_in&quot;&gt;origin&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;is&lt;/span&gt; our server name &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; twitter-experiment &lt;span class=&quot;built_in&quot;&gt;is&lt;/span&gt; the branch&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更新：感谢 Erlend 在博客文章评论中提到的 - 这实际上和 git push origin twitter-experiment 达到的效果的一样，但是通过使用全部语法，你能看到你实际上在两端使用了不同的名字（你的本地名字可能是 add-ssl-support，而远程名字可能是 issue-1723）。&lt;/p&gt;
&lt;p&gt;如果你想删除一个远程服务器上的分支（请注意分支名称之前的冒号）：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git push origin &lt;span class=&quot;symbol&quot;&gt;:twitter-experiment&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想显示所有远程分支的状态，你能像这样查看它们：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git remote &lt;span class=&quot;built_in&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;origin&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这可能会列出一些服务器上曾经有过但现在已不存在的分支。如果碰到这种情况，你可以很轻松地使用如下命令从本地检出并将其删除：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git remote prune&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后，如果你有一个远程分支，你想在本地进行跟踪它，通常的做法是：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git branch --track myfeature origin/myfeature&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout myfeature&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，如果你使用 -b 标识符去检出的话，新版的 Git 会自动建立跟踪：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git checkout -&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; myfeature origin/myfeature&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;在临时存放区、索引和文件系统中保存内容&quot;&gt;&lt;a href=&quot;#在临时存放区、索引和文件系统中保存内容&quot; class=&quot;headerlink&quot; title=&quot;在临时存放区、索引和文件系统中保存内容&quot;&gt;&lt;/a&gt;在临时存放区、索引和文件系统中保存内容&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;10. 临时存放（Stashing）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Git中，你可以把当前的工作状态储存在一个临时的存储区域堆栈，然后重新加以利用。简单的案例如下：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git stash &lt;span class=&quot;comment&quot;&gt;# Do something...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git stash pop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很多人推荐使用 git stash apply 来代替 “pop”，然而如果你真这么做的话，你最终得到一个长长的毫无用处的储藏清单。如果对它进行清理，“pop” 只会把它从堆栈中删除。如果你已经使用了 git stash apply ，你可以使用如下命令从堆栈中删除最后一项：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git stash drop&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Git 会基于当前的提交消息自动创建一个注释信息。如果你更喜欢使用一个自定义的消息（因为它可能和之前的提交无关）：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git stash save &lt;span class=&quot;string&quot;&gt;&quot;My stash message&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你想从你的列表中（不必是最后一个）对一个特定的 stash 加以利用，你可以列出它们并像这样来使用它：&lt;/p&gt;
&lt;figure class=&quot;highlight mathematica&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git stash list&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  stash@&amp;#123;0&amp;#125;: &lt;span class=&quot;keyword&quot;&gt;On&lt;/span&gt; master: Changed to German&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  stash@&amp;#123;1&amp;#125;: &lt;span class=&quot;keyword&quot;&gt;On&lt;/span&gt; master: &lt;span class=&quot;keyword&quot;&gt;Language&lt;/span&gt; is now Italian&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git stash apply stash@&amp;#123;1&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;11. 交互式添加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Subversion 的世界里，你修改文件然后只是提交有变化的文件。而在 Git 的世界里，你在提交某些文件甚至某些补丁上有更多的控制权。为了提交某些文件或者文件的某些部分，你必须进入交互模式。&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;add&lt;/span&gt; -i&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;           staged     unstaged path&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*** Commands ***&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: status      &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;   &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;: revert   &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;add&lt;/span&gt; untracked&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;: patch      &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;: diff     &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;quit&lt;/span&gt;     &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;help&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;What now&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这会让你进入一个基于交互式命令的菜单模式。你可以使用命令的数字符号或者加亮字符（如果你开启颜色高亮显示功能的话）进入对应模式，然后就是正常输入文件数的问题了（你可以使用像1或1-4或2,4,7这样的格式）。&lt;/p&gt;
&lt;p&gt;如果你想进入修补模式（交互模式下输入‘p’或‘5’ ），你也可以直接进入那个模式：&lt;/p&gt;
&lt;figure class=&quot;highlight diff&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git add -p    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;diff --git a/dummy.rb b/dummy.rb  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;index 4a00477..f856fb0 100644  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;--- a/dummy.rb&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;+++ b/dummy.rb&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@@ -1,5 +1,5 @@&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; class MyFoo&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   def say&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;deletion&quot;&gt;-    puts &quot;Annyong Haseyo&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;addition&quot;&gt;+    puts &quot;Guten Tag&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   end&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; end&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Stage this hunk [y,n,q,a,d,/,e,?]?&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如你所见，在底部你得到一系列选项为选择去添加文件改变的部分，这个文件的所有变化等等。使用‘?’ 命令可以了解选不同选项的解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. 存储/从文件系统检索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些项目（例如 Git 项目自身）直接在 Git 文件系统中存储额外的文件而不必是检入文件。&lt;/p&gt;
&lt;p&gt;让我们开始在 Git 中存储一个任意文件：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Foo&quot;&lt;/span&gt; | git &lt;span class=&quot;built_in&quot;&gt;hash&lt;/span&gt;-object -w --stdin&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;51&lt;span class=&quot;built_in&quot;&gt;fc&lt;/span&gt;03a9bb365fae74fd2bf66517b30bf48020cb&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时，该文件对象已在数据库中，但是如果你不设置（一些东西）指向那个文件对象，它将被作为垃圾而回收。最简单的方法是标记它：&lt;/p&gt;
&lt;figure class=&quot;highlight crmsh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myfile&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;51&lt;/span&gt;fc03a9bb365fae74fd2bf66517b30bf48020cb&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然在这里我们已经标记了 myfile。当我们需要获取该文件时，我们可以这样做：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;$&lt;/span&gt; git cat-&lt;span class=&quot;keyword&quot;&gt;file&lt;/span&gt; blob myfile&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序员可能经常用到的工具文件（密码、GPG 密钥、等等），不需要每次都检出到磁盘上（特别是在生产环境下），这种方法非常有效。&lt;/p&gt;
&lt;h1 id=&quot;日志记录&quot;&gt;&lt;a href=&quot;#日志记录&quot; class=&quot;headerlink&quot; title=&quot;日志记录&quot;&gt;&lt;/a&gt;日志记录&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;13. 查看日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你不使用‘git log’查看最近提交历史的话，你就不能长时间顺利地使用 Git。但是，也存在一些如何更好使用它的建议。例如，你可以查看每次提交中改变的一个补丁：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;$&lt;/span&gt; git &lt;span class=&quot;built-in&quot;&gt;log&lt;/span&gt; -p&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者你可以只是查看一个哪些文件有所更改的概述：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--stat&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以在一行中设置一个不错的别名，用于显示简短的提交和漂亮的带有消息的分支图（像 gitk，但在命令行上）：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git config --global &lt;span class=&quot;built_in&quot;&gt;alias&lt;/span&gt;.lol &lt;span class=&quot;string&quot;&gt;&quot;log --pretty=oneline --abbrev-commit --graph --decorate&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git lol&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* 4d2409a (master) Oops, meant that to be &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; Korean&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;169b845&lt;/span&gt; Hello world&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;14. 检索日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你想在日志中查询一个特定作者，你可以这样指定：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--author=Andy&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更新：感谢 Johannes 的评论，我终于化解了一部分困惑。&lt;/p&gt;
&lt;p&gt;或者如果你有一个搜索词出现在提交消息中：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--grep=&quot;Something in the message&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一个功能更强大的叫 pickaxe 的命令，它可以查找条目用来添加或删除一个特定的内容（也就是，当它第一次出现或被删除的时候）。这样你就可以知道何时增加了一行（但是如果那一行中的字符随后被改变，你将无从得知）：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git log -S &quot;TODO: &lt;span class=&quot;keyword&quot;&gt;Check&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;admin&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你改变一个特定的文件会怎么样呢，例如 lib/foo.rb&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git log &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;rb&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如说你有一个 feature/132 分支和一个 feature/145 分支，你想查看在这些分支但却不在主分支上的提交（备注：^ 代表非）：&lt;/p&gt;
&lt;figure class=&quot;highlight maxima&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;feature&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;132&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;feature&lt;/span&gt;/&lt;span class=&quot;number&quot;&gt;145&lt;/span&gt; ^master&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也可以使用 ActiveSupport 风格的日期缩小日期范围：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git log --since=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.months&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ago&lt;/span&gt; --until=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.day&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ago&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它默认使用 OR 模式来组合查询，但是你也可以很轻松地改为 AND 模式（如果你的查询项不止一个的话）&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git log --since=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.months&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ago&lt;/span&gt; --until=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.day&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.ago&lt;/span&gt; --author=andy -S &lt;span class=&quot;string&quot;&gt;&quot;something&quot;&lt;/span&gt; --all-match&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;15. 选择查看/修改的版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当引用一个修订版本时，你有许多选项可以选择，当然，这取决于你对此功能的了解程度：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;a86bc38 # &lt;span class=&quot;keyword&quot;&gt;By&lt;/span&gt; revision&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; v1&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt; # &lt;span class=&quot;keyword&quot;&gt;By&lt;/span&gt; tag&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; feature132 # &lt;span class=&quot;keyword&quot;&gt;By&lt;/span&gt; branch &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;a86bc38^ # &lt;span class=&quot;keyword&quot;&gt;Parent&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;commit&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;a86bc38~&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; # Grandparent &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;commit&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; feature132@&amp;#123;yesterday&amp;#125; # &lt;span class=&quot;keyword&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;relative&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;show&lt;/span&gt; feature132@&amp;#123;&lt;span class=&quot;number&quot;&gt;2.&lt;/span&gt;hours.ago&amp;#125; # &lt;span class=&quot;keyword&quot;&gt;Time&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;relative&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;请注意，和上一节有所不同，在行尾的脱字符表示提交的 parent - 行首的脱字符则表示不在这个分支上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16. 选择一个范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简单的方法是这样来用：&lt;/p&gt;
&lt;figure class=&quot;highlight livecodeserver&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;log&lt;/span&gt; origin/master..&lt;span class=&quot;built_in&quot;&gt;new&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# [old]..[new] - everything you haven&#39;t pushed yet&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也可以删除 [new]，这将使用当前的 HEAD。&lt;/p&gt;
&lt;h1 id=&quot;时间回退和错误修复&quot;&gt;&lt;a href=&quot;#时间回退和错误修复&quot; class=&quot;headerlink&quot; title=&quot;时间回退和错误修复&quot;&gt;&lt;/a&gt;时间回退和错误修复&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;17. 重置更改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你还没有提交一个更改，你可以很容易地重置它：&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git reset HEAD &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;rb&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常使用‘unstage’作为别名比较好，因为它不是那么显而易见。&lt;/p&gt;
&lt;figure class=&quot;highlight crystal&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git config --global &lt;span class=&quot;keyword&quot;&gt;alias&lt;/span&gt;.unstage &lt;span class=&quot;string&quot;&gt;&quot;reset HEAD&quot;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git unstage &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;lib&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;rb&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你已经提交了文件，你可以做两件事情 - 如果是最后一次提交，你可以这样来修改：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;--amend&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这将回滚到最后一次提交，让你的工作副本回到变化存储在暂存区的状态，你可以编辑提交消息准备下一次提交。&lt;/p&gt;
&lt;p&gt;如果你的提交不止一次，并且只想完全回滚它们，你可以重置分支回到之前的时间点。&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout feature132&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git reset --hard HEAD~&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你真的想把分支指向一个完全不同的 SHA-1（也许你把一个分支的 HEAD 指向另一个分支，或者进一步提交），你可以按照以下方式去做：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout FOO&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git reset --hard SHA&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上还有一种更便捷的方式（因为它不会先将你的工作副本变回最初 FOO 状态，然后再指向 SHA）：&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;keyword&quot;&gt;ref&lt;/span&gt; refs/heads/FOO &lt;span class=&quot;keyword&quot;&gt;SHA&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;18. 提交到错误的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好吧，让我们假设你提交到主分支，但应该已经创建了一个叫做 experimental 的主题分支。为了移除这些变化，你可以在当前点创建一个分支，回退 HEAD，然后检出新的分支：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git branch experimental   &lt;span class=&quot;comment&quot;&gt;# Creates a pointer to the current master state&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git reset --hard master~&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Moves the master branch pointer back to 3 revisions ago&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout experimental&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你已经在一个分支的一个分支的一个分支等上面做了些变更，这将会更复杂。然后你需要做的就是在这个分支上将其变更 rebase 到另一个的地方：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git branch newtopic STARTPOINT&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git rebase oldtopic --onto newtopic&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;19. 交互式 rebasing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个很酷的特性，我之前已看过演示，但当时没有真正搞明白，现在来看其实很简单。比方说，你已做了3次提交，但是你想对它们进行重新排序或者编辑（或者合并它们）：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git rebase -&lt;span class=&quot;selector-tag&quot;&gt;i&lt;/span&gt; master~&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后你将编辑器打开。你所要做的就是修改 “pick/squash/edit 的指令来进行如何提交，然后保存/退出。在编辑之后，你可以使用 git rebase —continue 让你的每一个指令一个一个进行。&lt;/p&gt;
&lt;p&gt;如果你选择编辑一个文件，这会让你停留在你提交时的状态，因此你需要使用 git commit —amend 对它进行编辑。&lt;/p&gt;
&lt;p&gt;备注：在 REBASE 过程中不要进行提交工作 - 只能添加然后使用 —continue, —skip or —abort 选项。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20. 清理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你已经提交了一些内容到你的分支中（也许你是从SVN中的旧代码库导入的），你想从历史中删除掉所有的已提交内容：&lt;/p&gt;
&lt;figure class=&quot;highlight mel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;filter&lt;/span&gt;-branch --tree-&lt;span class=&quot;keyword&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;rm -f *.class&#39;&lt;/span&gt; HEAD&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你已经向远程服务器推送过代码，但自那之后提交的都是一些垃圾，在推送之前你可以在本地系统上执行这样的操作：&lt;/p&gt;
&lt;figure class=&quot;highlight mel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;filter&lt;/span&gt;-branch --tree-&lt;span class=&quot;keyword&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;rm -f *.class&#39;&lt;/span&gt; origin/master..HEAD&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;各种各样的提示&quot;&gt;&lt;a href=&quot;#各种各样的提示&quot; class=&quot;headerlink&quot; title=&quot;各种各样的提示&quot;&gt;&lt;/a&gt;各种各样的提示&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;21. 之前你看过的引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你知道你之前已经查看过一个 SHA-1，但是你已经做了一些重置/回退工作，你可以使用 reflog 命令去查看你最近看过的 SHA-1：&lt;/p&gt;
&lt;figure class=&quot;highlight stata&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git reflog&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;log&lt;/span&gt; -&lt;span class=&quot;keyword&quot;&gt;g&lt;/span&gt; # Same &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; above, but shows &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; &#39;&lt;span class=&quot;keyword&quot;&gt;log&lt;/span&gt;&#39; &lt;span class=&quot;keyword&quot;&gt;format&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;22. 分支命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个可爱的小提示 - 请记住，分支的名字并不局限于 a-z 和 0-9 这些字符。名字中可以使用 / 和 . 来伪装命名空间或者版本号，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ # Generate a changelog of Release &lt;span class=&quot;number&quot;&gt;132&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git shortlog release/&lt;span class=&quot;number&quot;&gt;132&lt;/span&gt; ^release/&lt;span class=&quot;number&quot;&gt;131&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ # Tag this as v1&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ git tag v1&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt; release/&lt;span class=&quot;number&quot;&gt;132&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;23. 寻找谁是始作俑者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;寻找谁更改了一个文件中的一行代码经常会用到。简单命令如下：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;$&lt;/span&gt; git blame &lt;span class=&quot;keyword&quot;&gt;FILE&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时更改来自于前一个文件（如果你已经合并了两个文件，或者你已经移动了一个函数），因此你可以这样用：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;# shows which file names the content came from&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git blame -C FILE&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有时通过向前或向后点击来进行变化跟踪，这是很好的方法。有一个内置的 GUI 程序专门为此设计：&lt;/p&gt;
&lt;figure class=&quot;highlight gams&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;$&lt;/span&gt; git gui blame &lt;span class=&quot;keyword&quot;&gt;FILE&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;24. 数据库维护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Git 通常不需要大量维护，它基本上可以自我维护。然而，你可以使用如下命令查看数据库统计信息：&lt;/p&gt;
&lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt;-objects -v&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果数值很高，你可以选择使用垃圾回收你的重复内容。这不会影响推送或者其它用户，但却可以让你的命令运行更快且占用更少空间：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git gc&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;经常运行一致性检查也是值得推荐的做法：&lt;/p&gt;
&lt;figure class=&quot;highlight ada&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git fsck &lt;span class=&quot;comment&quot;&gt;--full&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你也可以在行尾添加一个 —auto 参数（如果你频繁运行它，或者在你的服务器上每日从 crontab 中运行它），如果统计数据表明必须进行要进行一致性检查，只要 fsck 命令就行。&lt;/p&gt;
&lt;p&gt;如果检查 “dangling” 或 “unreachable” 的结果一切正常，这经常是由于回退 HEAD 或 rebasing的结果。如果检查“missing” 或 “sha1 mismatch” 出了问题…寻求专业帮助吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;25. 恢复一个丢失的分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用 -D 选项删除了一个分支 experimental，你可以重新创建它：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ git &lt;span class=&quot;keyword&quot;&gt;branch &lt;/span&gt;experimental SHA1_OF_HASH&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;你可以使用 git reflog 来发现一个 SHA-1 哈希值，如果你近期访问过它的话。&lt;/p&gt;
&lt;p&gt;另一种方法是使用 git fsck —lost-found。一个悬空的提交就是一个 lost HEAD（它只会是一个已删除分支的 HEAD，因为当一个 HEAD^ 被 HEAD 引用时，它就没有悬空）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;作者： Andy Jeffries，Ruby on Rails 开发者 &amp;amp; 跆拳道教练，生活在英国伦敦。&lt;/p&gt;
&lt;p&gt;原文： 25 Tips for Intermediate Git Users（2009）&lt;/p&gt;
&lt;p&gt;感谢： Jodoo 帮助审阅并完成校对。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;img src=&quot;/blog/public/2015/08/26/Git中级用户的25个提示/git.png&quot; alt=&quot;[Git]&quot; title=&quot;[Git]&quot;&gt;
&lt;h1 id=&quot;基本提示&quot;&gt;&lt;a href=&quot;#基本提示&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="git" scheme="http://rocxing.github.io/blog/public/categories/git/"/>
    
    
      <category term="git" scheme="http://rocxing.github.io/blog/public/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Python缩进tips</title>
    <link href="http://rocxing.github.io/blog/public/2015/08/24/Python%E7%BC%A9%E8%BF%9Btips/"/>
    <id>http://rocxing.github.io/blog/public/2015/08/24/Python缩进tips/</id>
    <published>2015-08-24T07:28:08.000Z</published>
    <updated>2016-06-28T07:05:03.049Z</updated>
    
    <content type="html">&lt;p&gt;Python有着严格的代码缩进，这使得整个语言具有更高的可读性，代码看起来更加优美，赏心悦目。&lt;br&gt;但这种缩进控制的嵌套语言有一些小“坑”需要注意。&lt;/p&gt;
&lt;p&gt;下面是一段tab制表符和空格缩进混用的例子：&lt;/p&gt;
&lt;img src=&quot;/blog/public/2015/08/24/Python缩进tips/code.png&quot; alt=&quot;[代码]&quot; title=&quot;[代码]&quot;&gt;
&lt;p&gt;这段代码的意思很简单，理论上是没有输出结果的，因为1和2的打印输出都在if判断中，而其条件为False不会执行。然而执行这段代码的结果是输出了2！&lt;/p&gt;
&lt;p&gt;我们可以注意到，&lt;code&gt;print &amp;#39;1&amp;#39;&lt;/code&gt;前面为2个&lt;strong&gt;tab制表符&lt;/strong&gt;的缩进，而&lt;code&gt;print &amp;#39;2&amp;#39;&lt;/code&gt;前面为8个&lt;strong&gt;空格&lt;/strong&gt;的缩进。对于python解释器，它认为8个空格才是一个缩进而非我们约定俗成的4个，因此&lt;code&gt;print &amp;#39;2&amp;#39;&lt;/code&gt;前面相当于只有一个tab制表符，最终输出了2。&lt;/p&gt;
&lt;p&gt;为了避免这种代码缩进导致的逻辑错误，推荐使用Pycharm IDE，其具有PEP8代码规范的警告提示，并将tab自动替换为4个空格，从而避免了tab制表符和空格缩进的混用问题。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Python有着严格的代码缩进，这使得整个语言具有更高的可读性，代码看起来更加优美，赏心悦目。&lt;br&gt;但这种缩进控制的嵌套语言有一些小“坑”需要注意。&lt;/p&gt;
&lt;p&gt;下面是一段tab制表符和空格缩进混用的例子：&lt;/p&gt;
&lt;img src=&quot;/blog/public/2015
    
    </summary>
    
      <category term="Python" scheme="http://rocxing.github.io/blog/public/categories/Python/"/>
    
    
      <category term="Python" scheme="http://rocxing.github.io/blog/public/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>git ^和~</title>
    <link href="http://rocxing.github.io/blog/public/2015/08/20/git%E5%BC%95%E7%94%A8%E7%88%B6%E8%8A%82%E7%82%B9/"/>
    <id>http://rocxing.github.io/blog/public/2015/08/20/git引用父节点/</id>
    <published>2015-08-20T04:30:11.000Z</published>
    <updated>2016-06-28T07:05:03.052Z</updated>
    
    <content type="html">&lt;p&gt;有时候为了方便，我们经常使用~与^的运算符号来引用git的某一次提交。git仓库中的每一次提交都是一个节点，形成了一颗树状结构。因此，我们只需要指明第几个前驱节点，就可以轻松的引用前驱节点的提交。有了^和~，我们就不用每次都使用冗长的提交哈希值了。  &lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git revert HEAD~&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$ &lt;/span&gt;git checkout HEAD^^&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;和-总结如下：&quot;&gt;&lt;a href=&quot;#和-总结如下：&quot; class=&quot;headerlink&quot; title=&quot;^和~总结如下：&quot;&gt;&lt;/a&gt;^和~总结如下：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;“^”代表父提交，当一个提交有多个父提交时，可以通过在“^”后面跟上一个数字，表示第几个父提交，“^”相当于是“^1”的省略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;“~&lt;n&gt;”相当于连续的n个“^”。&lt;/n&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;checkout只会移动HEAD指针，reset会改变HEAD的引用值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;有时候为了方便，我们经常使用~与^的运算符号来引用git的某一次提交。git仓库中的每一次提交都是一个节点，形成了一颗树状结构。因此，我们只需要指明第几个前驱节点，就可以轻松的引用前驱节点的提交。有了^和~，我们就不用每次都使用冗长的提交哈希值了。  &lt;/p&gt;
&lt;p&gt;如：&lt;
    
    </summary>
    
      <category term="git" scheme="http://rocxing.github.io/blog/public/categories/git/"/>
    
    
      <category term="git" scheme="http://rocxing.github.io/blog/public/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>我的博客上线啦</title>
    <link href="http://rocxing.github.io/blog/public/2015/08/18/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E4%B8%8A%E7%BA%BF%E5%95%A6/"/>
    <id>http://rocxing.github.io/blog/public/2015/08/18/我的博客上线啦/</id>
    <published>2015-08-18T07:59:11.000Z</published>
    <updated>2016-06-28T07:05:03.055Z</updated>
    
    <content type="html">&lt;h2 id=&quot;2015-8-18，我的博客终于上线了&quot;&gt;&lt;a href=&quot;#2015-8-18，我的博客终于上线了&quot; class=&quot;headerlink&quot; title=&quot;2015.8.18，我的博客终于上线了&quot;&gt;&lt;/a&gt;2015.8.18，我的博客终于上线了&lt;/h2&gt;&lt;p&gt;不过还不大习惯Markdown的语法=.=&lt;br&gt;接下来熟悉一下语法应该就可以写文章了&lt;br&gt;总之先放到github上去。。。。  &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2015-8-18，我的博客终于上线了&quot;&gt;&lt;a href=&quot;#2015-8-18，我的博客终于上线了&quot; class=&quot;headerlink&quot; title=&quot;2015.8.18，我的博客终于上线了&quot;&gt;&lt;/a&gt;2015.8.18，我的博客终于上线了&lt;/h2&gt;&lt;p&gt;不过
    
    </summary>
    
      <category term="New" scheme="http://rocxing.github.io/blog/public/categories/New/"/>
    
    
      <category term="博客" scheme="http://rocxing.github.io/blog/public/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
